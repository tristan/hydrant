import os
import array
import random

from ptolemy.actor import Initializable, TypedAtomicActor, TypedIOPort
from ptolemy.data.type import BaseType
from ptolemy.data import StringToken
from ptolemy.kernel.util import SingletonAttribute, Attribute
from ptolemy.data.expr import StringParameter
from ptolemy.moml import MoMLFilter, MoMLParser
from au.edu.jcu.kepler.hydrant import ReplacementManager
#from org.kepler.provenance import ProvenanceListener, TextFileRecording

from org.ecoinformatics.seek.R import RExpression
from ptolemy.actor.lib.io import LineWriter
from org.geon import BinaryFileWriter

from settings import STORAGE_ROOT
from hydrant.models import *

class TestRM(ReplacementManager):
    """
    a testing replacement manager
    just prints the received data to the console
    """
    def __init__(self, container, name):
        ReplacementManager.__init__(self, container, name)
        self.storage_directory = StringParameter(self, "storage directory")

    def writePythonData(self, data):
        print type(data)
        print data
        job_name = data.get('name', 'unnamed')
        job_type = data.get('type', 'unknown')

class DefaultReplacementManager(ReplacementManager):
    """ The replacement manager is injected into the workflow when a job is started.
    This is used as a proxy for actors to send data back to the portal. Originally
    this was used directly by Replacement Actors as a one way channel, but is now being
    used by the actor-io module (see src/main/java/au/edu/jcu/kepler/hydrant/io/) for
    two way communication between the workflow and the portal and should probably be
    renamed to something more descriptive.
    """
    
    def __init__(self, container, name, jobid):
        ReplacementManager.__init__(self, container, name)
        self.jobid = jobid
        try:
            os.makedirs('%s/jobs/%s/' % (STORAGE_ROOT, self.jobid))
        except:
            if not os.path.exists('%s/jobs/%s/' % (STORAGE_ROOT, self.jobid)):
                raise

        self.iodevices = {}
    def writePythonData(self, data):
        """ takes a python dictionary and uses it to write the specified data to a file
        the python dictionary usually contains the following:

        output -- the data to write to the file
        name -- the name of the actor where the data was created
        type -- the type of the data, special inputs are BINARY and IMAGE, everything else is assumed as TEXT
        filename -- the filename to write the data to, will be autogenerated if it's not supplied.

        """
        output = data.get('output', None)
        if output == None:
            output = ''
        name = data.get('name', 'unnamed')
        type = data.get('type', 'unknown')
        file_name = data.get('filename', None)
        if file_name == None:
            binary = (type == 'BINARY' or type == 'IMAGE')
            ext = type
            if type == 'IMAGE':
                ext = data.get('format', 'RAW')
            file_name = '%s/jobs/%s/%s.%s' % (STORAGE_ROOT, self.jobid, name.replace('.', '_'), ext)
            
        f = open(file_name, '%s%s' % (os.path.exists(file_name) and 'a' or 'w', binary and 'b' or '',))
        if isinstance(output, array.array):
            output.tofile(f)
        else:
            f.write(output)
        f.close()
        j, created = JobOutput.objects.get_or_create(name=name, type=type,
                                                     file=file_name,
                                                     job=Job.objects.get(pk=self.jobid))
        j.save()
    def getCurrentUsername(self):
        j = Job.objects.get(pk=self.jobid)
        return j.owner.username
    def get_storage_dir(self):
        return '%s/jobs/%s' % (STORAGE_ROOT, self.jobid)

    def setWaitingForInput(self, prompt, itype, iodev):
        print 'setting wait status for job with prompt', prompt
        job=Job.objects.get(pk=self.jobid)
        ji = JobRuntimeInput(job=job,
                             actor=iodev.getOwnerName(),
                             inputtype=itype,
                             prompt=prompt)
        ji.save();
        job.status = 'WAITINGFORINPUT'
        job.save();
        print 'job state should now be updated'
        self.iodevices[ji.pk] = iodev

    def sendResultToWaitingInput(self, inputid):
        """ sets the input for a waiting io device.
        The value to send to the device is retrieved from
        the JobRuntimeInput instance.

        This function is NOT responsible for changing the job's
        state in the database.
        
        inputid can be either a RuntimeJobInput object or the
        pk of the object.
        """
        if isinstance(inputid, JobRuntimeInput):
            ji = inputid
        else:
            ji = JobRuntimeInput.objects.get(pk=inputid)
        if ji == None or not self.iodevices.has_key(ji.pk):
            raise Exception('input %s does not exist' % inputid)

        iodev = self.iodevices[ji.pk]
        iodev.setInput(ji.value)
        
    

'''
class ProvenanceListenerWrapper(ProvenanceListener):
    """The provenance listener was injected into every workflow at run time to
    record the provenance information for each job.

    This is currently disabled due to changes in the kepler provenance libraries
    breaking the current implementation.
    """
    
    def __init__(self, container, name, jobid):
        Attribute.__init__(self, container, name)
        file_name = '%s/jobs/%s/provenance.txt' % (STORAGE_ROOT, jobid)
        self.recordingType.setExpression('Text File')
        self.attributeChanged(self.recordingType)
        try:
            f = [p for p in self.attributeList() if p.getName() == "Filename"][0]
        except:
            raise Exception('unable to find Filename property in provenance listener actor')
        f.setExpression(file_name)
        jo = JobOutput(name='Provenance Data', type='TEXT', file=file_name, job=Job.objects.get(pk=jobid))
        jo.save()
'''

def modify_rexpression_actors(model, replacement_manager):
    """ This function traverses a workflow to find all the RExpression and File Writing actors
    and modifys their output directories so that they write to the storage directory specific
    to the job they belong to.

    TODO: the name of this function doesn't reflect what it does. fix.
    """
    for e in model.allAtomicEntityList():
        if isinstance(e, RExpression):
            e.Rcwd.setExpression(replacement_manager.get_storage_dir())
        elif isinstance(e, (LineWriter, BinaryFileWriter)):
            e.fileName.setExpression('%s/%s' % (replacement_manager.get_storage_dir(), e.getName()))
    for e in model.allCompositeEntityList():
        modify_rexpression_actors(e, replacement_manager)

